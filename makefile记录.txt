Mkefile 记录:

## 是makefile的 注释
@ 表明不回显执行的命令

make 认为目标总是一个文件
make比较目标文件和依赖文件的新旧关系觉得是否进行执行命令
make以文件处理方式作为第一优先级


通过 .PHONY 关键字声明一个为目标
伪目标不对应任何文件
不管为目标的依赖是否更新 总会执行对应命令	(所以 makefile中 的 clean 通常会先在 .PHONY 中声明防止 目录中出现 同名导致 命令不执行)

注意 :  .PHONY  是标准make中存在的 GUN make 也是存在的 如果说其他版本的不是标准的 make 可能是没有 .PHONY 关键字
这里 有技巧: 定义一个没有依赖的目标 
原理: 如果一个规则没有命令或者 没有依赖 而且目标不是一个存在的文件名  那么执行这个目标规则时候就总会是认为最新的 所以 对应以这个目标为依赖的目标就不是最新的 就总会被执行


makefile的变量 :
变量只代表字符串
变量大小写敏感

var := str  赋值
var ?= str	条件赋值	(当被var 在前面已经定义了 这里就不会在赋值 如果此时是第一次定义就将str赋值到var)
var += str	追加赋值	
var = str	递归赋值	
(
	x = foo 
	y = $(x)b
	x = new
	echo "x => $(x)"
	echo "y => $(y)"
输出:	
	x => new
	y => newb
)


预定义变量
自动变量: 
$@	表示当前规则中的目标  
$^  目标的所有依赖
$< 	规则的第一个依赖
等等....

特殊变量:
$(MAKE)			当前make解释器的文件名
$(MAKECMDGOALS) 	make 的命令行参数
$(MAKEFILE_LIST)	获取make 所需要处理的makefile 文件列表
$(MAKE_VERSION)		make 解释器的版本
$(CURDIR)			Makefile 的目录
$(.VARIABLES)		所有已经定义的变量名列表
$(RM)				rm -f


变量值的替换
$(var:a=b)			将var变量中的 后缀 a 替换为 b (格式中不能有空格)

example:
	src := a.c b.c
	obj := $(src:c=o)	#obj => a.o b.o

变量的模式替换
$(var:a%b=x%y)		将var变量中的 a 变量替换为 x , b 变量替换为 y , %表示保留变量值中的指定符

example:
	xx := aaabbbccc aaaeeeccc
	kk := $(xx:aaa%ccc=yyy%kkk)

	kk => yyybbbkkk yyyeeekkk

规则的模式替换：

exampl：
	OBJS := a.o b.o
	$(OBJS) : %.o : %.c		(%.o 匹配 OBJS 中的.o 字符串 %.c 则是将 %.o匹配好的字符串替换)
		gcc -o $@ -c $^			
		
	==>
		a.o : a.c
			gcc -o $@ -c $^
		
		b.o : b.c
			gcc -o $@ -c $^

变量值的嵌套引用
使用一个变量表示另一个变量

example:
	x := y
	y := z
	a := $($(x))  
	
	
命令行变量
运行 make 时在命令行定义变量
当命令行定义的变量与已经定义的变量名重复 就覆盖原有变量值

example:
	hm := hello 
	test:
		@echo "hm=> $(hm)"

	make hm=cmd		==>hm=>cmd


override 关键字
用于指定变量不能被覆盖

override var := xxx


define 关键字
定义多行变量	用endef结束

define foo	(变量名)
xxxxx		(值)
endef

override define cmd
	@echo "xxxx"	(命令)
	@ls				(命令)
endef







