Mkefile 记录:

## 是makefile的 注释
@ 表明不回显执行的命令

make 认为目标总是一个文件
make比较目标文件和依赖文件的新旧关系觉得是否进行执行命令
make以文件处理方式作为第一优先级

============================================================================================================================================
通过 .PHONY 关键字声明一个为目标
伪目标不对应任何文件
不管为目标的依赖是否更新 总会执行对应命令	(所以 makefile中 的 clean 通常会先在 .PHONY 中声明防止 目录中出现 同名导致 命令不执行)

注意 :  .PHONY  是标准make中存在的 GUN make 也是存在的 如果说其他版本的不是标准的 make 可能是没有 .PHONY 关键字
这里 有技巧: 定义一个没有依赖的目标 
原理: 如果一个规则没有命令或者 没有依赖 而且目标不是一个存在的文件名  那么执行这个目标规则时候就总会是认为最新的 所以 对应以这个目标为依赖的目标就不是最新的 就总会被执行

============================================================================================================================================
makefile的变量 :
变量只代表字符串
变量大小写敏感

var := str  赋值
var ?= str	条件赋值	(当被var 在前面已经定义了 这里就不会在赋值 如果此时是第一次定义就将str赋值到var)
var += str	追加赋值	
var = str	递归赋值	
(
	x = foo 
	y = $(x)b
	x = new
	echo "x => $(x)"
	echo "y => $(y)"
输出:	
	x => new
	y => newb
)

var1 :=
var2 := $(var1)

var3 = 
var4 = $(var3)

这两段代码 实际效果是不同的  因为赋值方式不同 make在加载进行预处理时候 var1 var2是直接赋值的 能直接指导是否有值  
var3 var4 是递归赋值的 var3 可以知道是直接空值 var4在加载时候是不知道是否值的需要在运行阶段才能确定 所以就先认为是有值的

============================================================================================================================================
预定义变量
自动变量: 
$@	表示当前规则中的目标  
$^  目标的所有依赖
$< 	规则的第一个依赖
等等....

特殊变量:
$(MAKE)			当前make解释器的文件名
$(MAKECMDGOALS) 	make 的命令行参数
$(MAKEFILE_LIST)	获取make 所需要处理的makefile 文件列表
$(MAKE_VERSION)		make 解释器的版本
$(CURDIR)			Makefile 的目录
$(.VARIABLES)		所有已经定义的变量名列表
$(RM)				rm -f

============================================================================================================================================
变量值的替换
$(var:a=b)			将var变量中的 后缀 a 替换为 b (格式中不能有空格)

example:
	src := a.c b.c
	obj := $(src:.c=.o)	#obj => a.o b.o

变量的模式替换
$(var:a%b=x%y)		将var变量中的 a 变量替换为 x , b 变量替换为 y , %表示保留变量值中的指定符

example:
	xx := aaabbbccc aaaeeeccc
	kk := $(xx:aaa%ccc=yyy%kkk)

	kk => yyybbbkkk yyyeeekkk

规则的模式替换：

exampl：
	OBJS := a.o b.o
	$(OBJS) : %.o : %.c		(%.o 匹配 OBJS 中的.o 字符串 %.c 则是将 %.o匹配好的字符串替换)
		gcc -o $@ -c $^			
		
	==>
		a.o : a.c
			gcc -o $@ -c $^
		
		b.o : b.c
			gcc -o $@ -c $^
针对目录结构的 规则的模式替换：
	%.o : %.c
		gcc -o $@ -c $^
把目录中所有.c文件替换为.o文件再逐一对其进行规则运行

变量值的嵌套引用
使用一个变量表示另一个变量

example:
	x := y
	y := z
	a := $($(x))  
	
============================================================================================================================================	
命令行变量
运行 make 时在命令行定义变量
当命令行定义的变量与已经定义的变量名重复 就覆盖原有变量值

example:
	hm := hello 
	test:
		@echo "hm=> $(hm)"

	make hm=cmd		==>hm=>cmd
============================================================================================================================================

override 关键字
用于指定变量不能被覆盖

override var := xxx

============================================================================================================================================
define 关键字
定义多行变量	用endef结束

define foo	(变量名)
xxxxx		(值)
endef

override define cmd
	@echo "xxxx"	(命令)
	@ls				(命令)
endef
============================================================================================================================================

环境变量
指操作系统的环境变量
makefile 定义了同名的变量 环境变量被覆盖  如果在make指定选项 -e 时优先使用环境变量


目标变量
作用域只在指定目标以及连带规则
局部变量优先级高于全局

example:
	var := DT
	test : var := test  (在test 作用域中 var 变量的值是 test)
	test:
		@echo "$(var)"
	
模式变量

	var := DT
	%t : var := test  (在以 t 结尾的作用域名 的作用域中 var 变量的值是 test)
	test:
		@echo "$(var)"
============================================================================================================================================	

条件判断语句
ifeq	判断是否相等	相等为true
ifneq	判断是否不相等	不等为true
ifdef	判断是否有值	有值为true
ifndef	判断是否无值	没有值为true

	ifxxx (a,b)	(无空格)
	#for true
	else
	#for false
	endif
============================================================================================================================================	
	
函数定义
make解释器有提供 一系列的预定义函数
自定义函数无法直接调用
自定义函数是一个过程调用 是没有返回值的
自定义函数是命令的集合用于规则中
自定义函数只能在规则中利用 call 调用 
自定义函数实际上就是多行变量

可通过 define 关键字自定义函数
example:
define func1
	@echo "$(0)"	(函数第0个参数)
	@echo "$(1)"
endef

test:
	$(call func1)
	$(call func1, XXXXX)
	
预定义函数
makefile 提供处理文件名, 变量, 命令的函数

var := $(func arg1, arg2)

$(wildcard param)			将自动获取当前目录的满足 param 的文件
$(addprefix prefix, names)	给名字列表 names 的每个名字增加一个前缀 prefix
$(subst from,to,text) 替换
$(patsubst pattern,replacement,text) 模式替换，可用%（只用第一个%有用），如 $(patsubst %.c,%.o,x.c.c bar.c)，结果 ‘x.c.o bar.o’
$(filter pattern…,text)  过滤，只保留pattern部分
$(foreach var,list,text) 相当于for循环函数
$(notdir _names)  去除文件名 _names 的路径前缀
$(patsubst pattern, replacement, text)	将 text 中的 pattern 替换为 replacement

================================================================================================================================================	
	
gcc 依赖关系选项
-M ：自动生成文件依赖关系
-MM ：生成文件依赖关系，不包括标准库
-MF file 把依赖关系写入file
-MT “rule” 按照指定规则rule 进行选中 意思是 把rule 指定为目标

================================================================================================================================================	
	
makefile 的include关键字
将文件内容复制到当前文件
当文件搜索失败就会以 文件名 作为目标查找对应规则并执行

当目标文件存在 并以目标文件名查找相应规则 比较时间 决定是否执行; 且同名规则被执行后 会重新加载目标文件

文件 规则都不存在则报错

include 注意点:
1. include 前加 - 号 会忽略警告同时会忽略掉 错误信息

2. 
.PHONY : all
-include test.txt

all : 
	@echo "xx"
test.txt : 
	@echo "other : @echo "this is other"" > test.txt
	
这段 执行make 的输出：
	this is other
原因: 因为如果 test.txt 不存在 则 -include 会执行 test.txt 规则将 other : @echo "this is other 写入 test.txt 然后
	  -include 会重新加载 test.txt 这时候 会把 other : @echo "this is other 赋值到 Makefile 让 other 成为第一个规则 
	  执行 make 后 会默认执行 第一个规则 就输出 this is other

3.
.PHONY : all
-include test.txt

all : 
	@echo "xx"
test.txt : b.txt
	@echo "creating"
	
这段 执行make 的输出：
	creating
原因: 因为 -include 导入 对应文件后 发现与文件同名的规则 就会去检测一下其时间 发现规则对应依赖的时间比导入的文件新 就会去执行
	  同名规则

================================================================================================================================================		
	
Makefile的命令执行机制

规则中的命令默认是在一个新的进程中执行, 执行完后进程销毁
可以通过接续符 ; 将多个命令组合在同一进程中执行
组合的命令会依次进行执行 无论命令执行过程中是否发生错误 后续命令都会被执行
set -e 可以指定发生错误后停止执行

================================================================================================================================================

自动生成依赖
通过 .d 文件保存依赖文件信息

有两种方式:
1. 通过 gcc -MM 选项获取不包含标准库的 依赖文件 -E 查看依赖项  并用 linux 命令 sed 文本流编辑 将输出语句修改 输出到 .d 依赖文件
   $(CC) -MM -E $^ | sed 's,\(.*\)\.o[ :]*,objs/\1.o : ,g' > $@

2. 通过gcc -MM 选项获取不包含标准库的 依赖文件 用 -MF 将获取的依赖信息输出到指定文件 (可选)再用 -MT 重新指定 依赖信息的目标
   $(CC) -MM -E $^ -MF"$(addprefix $(DEPS_DIR), $@)" -MT"$(addprefix $(DEPS_DIR), $(@:.d=.o))"

在例子 makefil_file2中 自动识别更新头文件的 关键在：
把要 include 进来的文件名同时加入到 .d 文件中作为目标 当 include .d 文件后 检查 目标文件的依赖文件的更新时间 如果是新的 就会寻找规则进行更新
在例子中 xx.d : xx.c xx.h, xx.c/xx.h 更新后 xx.d也需要更新 就寻找对应规则将 .d 文件进行更新 , 然后重新加载进来 

总结就是 通过 .d 文件的依赖文件是时间更新 来触发 .d 文件更新 .d 文件的更新再重新加载最后 .o 的依赖头文件也得到更新

================================================================================================================================================

make 的隐式规则

Makefile中出现同名目标时

依赖:
	所有的的依赖会结合到一起成为目标的最终依赖

命令:
	当多处出现同一目标的命令时 会发出警告
	所有之前的命令都会被后面的命令取代
	
当 make 发现目标依赖不存在时
	会尝试通过依赖名查找对应规则	
	并通过依赖名推导可能需要的源文件

app.out : main.o func.o		==> 	发现目标的依赖不存在					==> 执行 cc -c -o func.o func.c
	$(CC) -o $@ $^					寻找对应规则自动推导出 func.o : func.c		

隐式规则的副作用:
	编译行为不能控制  比如: 在工程文件中 当同时存在测试代码文件和发布版本代码文件时 隐式规则会自动把测试代码 也会加入到依赖中 然而测试代码有可能是其他语言的程序所以会出现奇怪的错误
	make 会从隐式规则和自定义中进行选择 导致编译效率低

================================================================================================================================================

make 的路径搜索

VPATH(大写) 预定义变量 指定 make 查找路径
当前文件夹找不到所需文件时 VPATH会使用

注意:
当多个文件夹存在同名文件时 选择第一个搜索到的文件

VPATH := path1 path2 ...

VPATH 只能决定 make 的搜索路径 不能决定命令的搜索路径
利用 gcc -I dir  -I 选项收到增加路径


vpath(小写) 关键字
可以为不同类型文件指定不同搜索路径
当有多个 vpath 时 make会自上而下顺序搜索指定文件夹

vpath %.h inc 

取消指定路径
vpath %.h

取消全部
vpath 

make 会优先选择 vpath 指定的路径进行搜索 当 vpath 搜索失败 就会再 到 VPATH 中搜索

注意:
	当目标文件完全不存在 则编译后就会在当前目录下生成 
	当目标文件在其他目录 且依赖没更新 再次 make 此时 make 会根据 VPATH 的路径下找对应的目标文件 找到就不会再当前目录生成目标文件
	当目标文件在其他目录 依赖更新了 再次 make 此时 make 就会在当前目录生成目标文件 不会在 VPATH 路径下找
	
GPATH 变量指定目标文件夹
	当目标文件完全不存在 就会在当前目录生成目标文件
	当目标文件

================================================================================================================================================























