Mkefile 记录:

## 是makefile的 注释
@ 表明不回显执行的命令

make 认为目标总是一个文件
make比较目标文件和依赖文件的新旧关系觉得是否进行执行命令
make以文件处理方式作为第一优先级

============================================================================================================================================
通过 .PHONY 关键字声明一个为目标
伪目标不对应任何文件
不管为目标的依赖是否更新 总会执行对应命令	(所以 makefile中 的 clean 通常会先在 .PHONY 中声明防止 目录中出现 同名导致 命令不执行)

注意 :  .PHONY  是标准make中存在的 GUN make 也是存在的 如果说其他版本的不是标准的 make 可能是没有 .PHONY 关键字
这里 有技巧: 定义一个没有依赖的目标 
原理: 如果一个规则没有命令或者 没有依赖 而且目标不是一个存在的文件名  那么执行这个目标规则时候就总会是认为最新的 所以 对应以这个目标为依赖的目标就不是最新的 就总会被执行

============================================================================================================================================
makefile的变量 :
变量只代表字符串
变量大小写敏感

var := str  赋值
var ?= str	条件赋值	(当被var 在前面已经定义了 这里就不会在赋值 如果此时是第一次定义就将str赋值到var)
var += str	追加赋值	
var = str	递归赋值	
(
	x = foo 
	y = $(x)b
	x = new
	echo "x => $(x)"
	echo "y => $(y)"
输出:	
	x => new
	y => newb
)

var1 :=
var2 := $(var1)

var3 = 
var4 = $(var3)

这两段代码 实际效果是不同的  因为赋值方式不同 make在加载进行预处理时候 var1 var2是直接赋值的 能直接指导是否有值  
var3 var4 是递归赋值的 var3 可以知道是直接空值 var4在加载时候是不知道是否值的需要在运行阶段才能确定 所以就先认为是有值的

============================================================================================================================================
预定义变量
自动变量: 
$@	表示当前规则中的目标  
$^  目标的所有依赖
$< 	规则的第一个依赖
等等....

特殊变量:
$(MAKE)			当前make解释器的文件名
$(MAKECMDGOALS) 	make 的命令行参数
$(MAKEFILE_LIST)	获取make 所需要处理的makefile 文件列表
$(MAKE_VERSION)		make 解释器的版本
$(CURDIR)			Makefile 的目录
$(.VARIABLES)		所有已经定义的变量名列表
$(RM)				rm -f

============================================================================================================================================
变量值的替换
$(var:a=b)			将var变量中的 后缀 a 替换为 b (格式中不能有空格)

example:
	src := a.c b.c
	obj := $(src:c=o)	#obj => a.o b.o

变量的模式替换
$(var:a%b=x%y)		将var变量中的 a 变量替换为 x , b 变量替换为 y , %表示保留变量值中的指定符

example:
	xx := aaabbbccc aaaeeeccc
	kk := $(xx:aaa%ccc=yyy%kkk)

	kk => yyybbbkkk yyyeeekkk

规则的模式替换：

exampl：
	OBJS := a.o b.o
	$(OBJS) : %.o : %.c		(%.o 匹配 OBJS 中的.o 字符串 %.c 则是将 %.o匹配好的字符串替换)
		gcc -o $@ -c $^			
		
	==>
		a.o : a.c
			gcc -o $@ -c $^
		
		b.o : b.c
			gcc -o $@ -c $^
针对目录结构的 规则的模式替换：
	%.o : %.c
		gcc -o $@ -c $^
把目录中所有.c文件替换为.o文件再逐一对其进行规则运行

变量值的嵌套引用
使用一个变量表示另一个变量

example:
	x := y
	y := z
	a := $($(x))  
	
============================================================================================================================================	
命令行变量
运行 make 时在命令行定义变量
当命令行定义的变量与已经定义的变量名重复 就覆盖原有变量值

example:
	hm := hello 
	test:
		@echo "hm=> $(hm)"

	make hm=cmd		==>hm=>cmd
============================================================================================================================================

override 关键字
用于指定变量不能被覆盖

override var := xxx

============================================================================================================================================
define 关键字
定义多行变量	用endef结束

define foo	(变量名)
xxxxx		(值)
endef

override define cmd
	@echo "xxxx"	(命令)
	@ls				(命令)
endef
============================================================================================================================================

环境变量
指操作系统的环境变量
makefile 定义了同名的变量 环境变量被覆盖  如果在make指定选项 -e 时优先使用环境变量


目标变量
作用域只在指定目标以及连带规则
局部变量优先级高于全局

example:
	var := DT
	test : var := test  (在test 作用域中 var 变量的值是 test)
	test:
		@echo "$(var)"
	
模式变量

	var := DT
	%t : var := test  (在以 t 结尾的作用域名 的作用域中 var 变量的值是 test)
	test:
		@echo "$(var)"
============================================================================================================================================	

条件判断语句
ifeq	判断是否相等	相等为true
ifneq	判断是否不相等	不等为true
ifdef	判断是否有值	有值为true
ifndef	判断是否无值	没有值为true

	ifxxx (a,b)	(无空格)
	#for true
	else
	#for false
	endif
============================================================================================================================================	
	
函数定义
make解释器有提供 一系列的预定义函数
自定义函数无法直接调用
自定义函数是一个过程调用 是没有返回值的
自定义函数是命令的集合用于规则中
自定义函数只能在规则中利用 call 调用 
自定义函数实际上就是多行变量

可通过 define 关键字自定义函数
example:
define func1
	@echo "$(0)"	(函数第0个参数)
	@echo "$(1)"
endef

test:
	$(call func1)
	$(call func1, XXXXX)
	
预定义函数
makefile 提供处理文件名, 变量, 命令的函数

var := $(func arg1, arg2)

$(wildcard param)			将自动获取当前目录的满足 param 的文件
$(addprefix prefix, names)	给名字列表 names 的每个名字增加一个前缀 prefix
$()
	
	
	
	
	




