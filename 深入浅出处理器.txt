GNU:
https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/index.html#toc_Invoking-GCC

=============================================================================================================
1.处理器启动流程

-处理器上电后 PC寄存器会固化一个默认值
-PC默认值用于决定执行第一条指令
-第一条指令用于启动程序(BootLoader)

上电后 内部寄存器就会被设置默认值, 然后根据 PC 的值(大多数是0)到对应地方执行第一条指令

=============================================================================================================
2.系统上电后启动的第一个程序是 BootLoader

根据运行阶段和功能可分为三部分:
	-BL0 固化于硬件,用于初始化硬件, 加载运行BL1
	-BL1 存储于外部存储器, 用于初始化主存, 加载运行BL2
	-BL2 存储于外部存储器, 用于引导操作系统

为什么分三步? (原因和 为什么模块化程序设计一样)

=============================================================================================================
3.中断:

中断服务程序(ISR)
-从外设读取中断状态寄存器的值,获取中断类型
-根据中断类型处理对应逻辑
-清除外设状态寄存器的状态标记
-清除处理器的中断标记

中断服务程序限制:
-不能有返回值 不能有参数(返回值不知道返回给谁 所以没意义, 参数谁传递?)
-必须短小 避免浮点

=============================================================================================================
4.内存管理单元

对内存进行高效管理的功能单元
操作系利用内存管理单元实现 虚拟内存 内存保护

应用程序开发时 面对的内存是虚拟内存
虚拟内存模式下使用的是虚拟地址
每个进程拥有独立的虚拟内存空间 
虚拟内存与实际的物理内存无关

虚拟内存能够支持多个大内存需求量的进程同时运行在小物理内存中
利用一个交换区的概念 在内存中只运行小部分代码 当这部分代码运行完后 交换区就会把新的代码加载到物理内存中
不断重复直至跑完全部代码

虚拟内存的机制:
-虚拟内存需要重新映射到物理内存
-虚拟地址映射到物理地址中的实地址
-每次只有进程中的少量代码运行在物理内存中
-大部分进程代码位于存储器中

页式内存管理:
-页式内存单位 指移动数量的内存(如: 4K)
-虚拟内存和物理内存都以页为单位管理
-进程的活动页被载入内存时, 记录页地址的映射关系

虚拟地址----> 映射表 -------> 物理地址

-页式管理内存将内存分两部分(p, d)
p -地址高位, 页面号
d -地址低位, 页内偏移

				 ------						------------------------
0xAABB 0000 --> |活动页| <-- 0xDD 0000 	   |虚拟页号|物理页号|  属性|
				|	   |				   |0xAABB  | 0xDD   | 0x00 |
				 ------					   |        |   ..   |      |
											------------------------
=============================================================================================================
5. 缓存

程序访问的局部性
-短时间内 处理器访问空间是一个很小的范围
-时间局部性
	某个存储单元在短时间内很可能再次被访问
-空间局部性
	某个存储单元的邻近单元在短时间也会被访问
	
处理器的速度是 远大于 内存 为了解决处理器经常需要等待内存
在处理器和内存件 设置 cache 缓存
把内存中被频繁访问的数据指令复制到 cache 中
大多数情况下处理器都可以从 cache 中取得指令
当处理器不能从 cache 获取数据 那么 就需要从内存中获取数据复制到 cache中

=============================================================================================================

6. 嵌入式 C 编译器

编译器编译顺序:
	预处理 (.i) -> 编译(.s) -> 汇编(.o) -> 链接
	  -E			-S			-c

生成映射文件:
	gcc -Wl -Map=xxx.map xxx.c

宏定义
	gcc -DXXX aaa.c

获取系统头文件路径
	gcc -v xxx.c

获取目标依赖关系(包含标准库)
	gcc -M xxx.c

获取目标依赖关系(不包含标准库)
	gcc -MM xxx.c
	
指定 库文件 以及 库文件路径
	-lxxx	指定目录文件xxx
	-Lsrc	指定路径src	
	gcc -L -lxxx

=============================================================================================================

7. 开发中的辅助工具

GCC 工具集
-addr2line  将代码地址装换为程序的行号
-strip 		裁剪程序的调试信息
-ar			打包为静态库	ar crs xx.a aa.o bb.o
-nm			列出目标文件的标识符  (输出格式:  0x12345 T func --> 标识符地址 段标识 标识符)
			(段标识 : B/b 未初始化数据段 bss
					  C 未定义存储段的标识符 连接时决定
					  D/d 数据段 .data
					  N 调试专用
					  R/r 位于只读存储区 .rdata
					  T/t 位于代码段 .text
					  U 未定义
			)
-objdump 	反汇编目标文件 查看汇编到源码的映射 (-d -S)
			查看目标文件详细段信息 (-h)
			输出说明 ldx 段下标
					 name 段标识符
					 size 段空间大小
					 VMA 段虚存起始地址
					 LMA 段加载目标地址
					 fileoff 段在目标文件的偏移
					 algn 对齐字节数

test.out 在桌面环境中运行 首先先分配一段虚拟内存 然后将 test.out 中各个段信息加载到虚存中
怎么加载 利用 test.out 中 Fileoff 获取各个段的偏移位置然后加载到虚存中的位置, 哪个位置？
位置在编译 test.out 时已经确定好了虚存地址(VMA),所以 在 test.out 获取, 此时 加载地址(LMA) 
和 VMA 值是相等的 是因为加载地址就是各个段的目标地址

test.out 在交叉编译后烧写到 nand flash时 运行前需要将 flash 对应地址(LMA)的程序烤到 ram 中怎么加载? 
利用加载地址把各个段信息加载到 ram 中 此时 LMA != VMA
烧写到 nor flash 时 不用烤到 ram 中 可以直接在 nor flash 中运行 这时运行地址等于加载地址 没有
虚拟地址 

=============================================================================================================

8. 链接器

GNU 的链接器: ld 命令

ld -static 以静态链接方式参数最终可执行程序

链接器的主要作用是把各个模块之间相互作用的部分处理好, 正确衔接各个模块

目标文件(.o)的秘密:
-目标文件中各个段信息是没有起始地址, 只有信息大小
-各个标识符没有实际地址, 只有段中的相对地址
-段和标识符的实际地址需要链接器具体确定

链接器作用：
-合并目标文件中的各个段
-确定各个段的最终地址(重定位)
-最后将目标文件整合为可执行程序


问题:  main() 函数是第一个被执行的函数?
	在 gcc 的编译下 (objdump -S )
	-程序第一个被加载是 _start()
	-_start()函数准备好参数后调用 _libc_start_main()
	-_libc_start_main()初始化环境后调用 mian()

延伸问题: 为什么 _start是第一个被执行函数?
	首先 _start() 的入口地址是 代码段(.text)的起始地址 (objdump -S ; objdump -h)
	linux 下加载程序的过程是: 创建虚拟内存空间 将可执行文件中各个段信息加载到虚存
	pc 指针就指向该程序的 代码段起始地址 作为 第一条指令执行
	
程序启动过程:
	_start() --> _libc_start_main() --> _libc_csu_init() --> _init() --> _do_blobal_ctors_aux
	--> main()
	

main() 是运行时的入口函数 不是加载时的入口函数
如果想 改变运行时入口函数 
gcc -e xxx 指定入口函数 在链接时 需要 -nostartfiles 选项

-nostdlib 不引入标准库和启动文件
-fno-builtin 禁止 gcc 利用内置函数替换 C函数

链接器依赖于链接脚本(.lds)

各个段的地址必须符合具体平台的规范
链接脚本能指定源码中标识符的存储地址

Linux 平台代码段的合法地址是 [0x08048000, 0x08049000]

SECTIONS	//关键字描述各个段在内存中的布局
{
	.text 0x2000000: { *(.text) }	// 代码段起始地址0x2000000 把各个目标文件的代码段合并
	
	. = 0x3000000	//将当前位置设置为0x3000000
	S = .			//设置标识符(全局变量)的地址
	
	.text 0x4000000: { *(.data) } // 数据段起始地址0x4000000 把各个目标文件的数据段合并
	.bss : { *(.bss) }			// 未初始化数据段起始地址默认(和平台和链接器有关) 
}

默认情况下 链接器会为程序加载在同一存储空间
在嵌入式系统中有可能会程序不同部分存储在不同空间

必须用 MEMORY 关键字定义
MEMORY 属性定义 : R(只读)  W(读写)  X(执行)  A(可分配)  !(反转属性) 

MEMORY
{
	RAM0 (WX) : ORIGIN = 0x2000000, LENGTH = 1024K //RAM 0 可读可写 起始地址0x200000 长度1024k
	RAM1 (!X) : ORIGIN = 0X4000000, LENGTH = 256K  //RAM 1 不可执行 ...
}
SECTIONS	
{
	.text 0x2000000: { *(.text) } > RAM0 
	.text 0x4000000: { *(.data) } > RAM1
	.bss : { *(.bss) }	> RAM1
}

ENTRY 指定入口

ENTRY(entry)
SECTIONS	
{
	.text 0x2000000: { *(.text) }
	.text 0x4000000: { *(.data) }
	.bss : { *(.bss) }	> RAM1
}

=============================================================================================================

9. 汇编的内嵌

语法格式
	asm volatile("汇编指令\n":"输出参数":"输入参数":"保留列表");

	-volatile 保证汇编的内嵌代码不会被编译器优化
	-输出/输入参数, 保留列表 是可选参数
	-汇编指令用 \n 结束
	-保留列表用于过滤寄存器是其不备系统自动分配关联变量

asm volatile(
	"movl %1, %0\n"
	:"=r"(res)
	:"r"(input)
);
说明: "=r" =指输出 r指自动管理寄存器到变量
	  %1 %0 占位符 指从上到下的参数
	  这条内嵌汇编是将 input 的值 传递到 res

asm volatile(
	"movl %%eax, %%ecx\n"
	"movl %%ebx, %%eax\n"
	"movl %%ecx, %%ebx\n"
	:"=a"(a), "=b"(b)
	:"a"(a), "b"(b)
);
说明: "=a" "=b" 将 a 寄存器关联到对应变量
	  这条内嵌汇编是 交换变量值

asm volatile(
	"movl $4, %%eax\n"
	"movl $1, %%ebx\n"
	"movl %0, %%ecx\n"
	"movl %1, %%edx\n"
	"int $0x80     \n"
	:
	: "r"(str), "r"(len)
	: "eax", "ebx", "ecx", "edx"
);
说明: int $0x80 是Linux内核中断服务指令 0x80是中断向量号
	  $4 是调用 sys_write 系统调用
	  $1 是标志输出
	  保留列表 "eax", "ebx", "ecx", "edx" 指不希望这些寄存器被关联到
	  变量
	  这条内嵌汇编是 打印语句





















